/* https://github.com/huguesjohnson/DubbelLib/blob/main/LICENSE */

package com.huguesjohnson.dubbel.retailclerk.build;

import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileWriter;
import java.util.ArrayList;
import java.util.HashMap;

import javax.imageio.ImageIO;

import com.huguesjohnson.dubbel.file.FileUtils;
import com.huguesjohnson.dubbel.file.PathResolver;
import com.huguesjohnson.dubbel.retailclerk.build.objects.PaletteMap;
import com.huguesjohnson.dubbel.retailclerk.build.objects.Tile8x8;
import com.huguesjohnson.dubbel.retailclerk.build.objects.Tileset;
import com.huguesjohnson.dubbel.retailclerk.build.parameters.TilesetParameters;
import com.huguesjohnson.dubbel.util.GenesisColorUtil;

public class BuildTiles extends BaseBuilder{

	@SuppressWarnings("resource") //everything is closed in finally block, Eclipse doesn't seem to understand that
	public static HashMap<String,Tileset> build(String basePath,TilesetParameters tiles,HashMap<String,PaletteMap> paletteMap) throws Exception{
		HashMap<String,Tileset> returnMap=new HashMap<String,Tileset>();
		FileWriter tileIncludeWriter=null;
		FileWriter tileWriter=null;
		FileWriter patternWriter=null;
		FileWriter patternIncludeWriter=null;
		Tileset currentEntry=null; //used for error messages if needed
		int row=-1;
		int col=-1;
		try{
			//setup include writers
			String tileIncludeFilePath=basePath+tiles.tileIncludeFilePath;
			tileIncludeWriter=new FileWriter(tileIncludeFilePath);
			tileIncludeWriter.write("; generated by build tools");
			tileIncludeWriter.write(newLine);
			tileIncludeWriter.write(newLine);
			String patternIncludeFilePath=basePath+tiles.patternIncludeFilePath;
			patternIncludeWriter=new FileWriter(patternIncludeFilePath);
			patternIncludeWriter.write("; generated by build tools");
			patternIncludeWriter.write(newLine);
			patternIncludeWriter.write(newLine);
			//loop through all tilesets
			for(Tileset entry:tiles.tilesets){
				currentEntry=entry;
				//if the palette is missing then bail
				PaletteMap palette=paletteMap.get(entry.palette);
				if(palette==null){throw(new Exception("Palette ["+entry.palette+"] not found."));}
				boolean allowDuplicateTiles=false;
				if((entry.allowDuplicateTiles!=null)&&(entry.allowDuplicateTiles.equalsIgnoreCase("TRUE"))){
					allowDuplicateTiles=true;
				}
				boolean createPattern=false;
				if((entry.patternFilePath!=null)&&(!entry.patternFilePath.isBlank())){
					createPattern=true;
				}
				//setup the tilewriter
				String tileOutputPath=basePath+entry.destinationFilePath;
				FileUtils.mkdirs(tileOutputPath);
				tileWriter=new FileWriter(tileOutputPath);
				tileWriter.write("; generated by build tools");
				tileWriter.write(newLine);
				//setup the patternwriter
				String patternOutputPath=null;
				if(createPattern){
					patternOutputPath=basePath+entry.patternFilePath;
					patternWriter=new FileWriter(patternOutputPath);
				}
				//read the source file
				String sourceFilePath=basePath+entry.sourceFilePath;
				tileWriter.write("; source file: "+entry.sourceFilePath);
				tileWriter.write(newLine);
				tileWriter.write(newLine);
				File sourceFile=new File(sourceFilePath);
				BufferedImage image=ImageIO.read(sourceFile);
				//get & test image width
				int width=image.getWidth();
				if(width%8!=0){throw(new Exception("Image width must be a multiple of 8 - sourceFile="+sourceFile));}
				//get & test image height
				int height=image.getHeight();
				if(height%8!=0){throw(new Exception("Image width must be a multiple of 8 - sourceFile="+sourceFile));}
				if(createPattern){
					patternWriter.write("; generated by build tools");
					patternWriter.write(newLine);
					patternWriter.write("; source file: "+entry.sourceFilePath);
					patternWriter.write(newLine);
					patternWriter.write(newLine);
					StringBuilder patternName=new StringBuilder();
					patternWriter.write(newLine);
					patternName.append("Pattern");
					patternName.append(entry.name);
					patternName.append(":");
					patternName.append(newLine);
					patternWriter.write(patternName.toString());
					int rowCount=height/8;
					patternWriter.write("\tdc.w\t$"+Integer.toHexString(rowCount-1).toUpperCase()+"\t; "+rowCount+" rows");
					patternWriter.write(newLine);
					int colCount=width/8;
					patternWriter.write("\tdc.w\t$"+Integer.toHexString(colCount-1).toUpperCase()+"\t; "+colCount+" columns");
					patternWriter.write(newLine);
				}
				ArrayList<Tile8x8> uniqueTiles=new ArrayList<Tile8x8>();
				//loop through all the pixels and filter out duplicate tiles
				row=0;
				while(row<height){
					col=0;
					while(col<width){
						Tile8x8 tile8x8=new Tile8x8();
						//loop through each pixel of the next 8x8 cell
						for(int x=col;x<(col+8);x++){
							for(int y=row;y<(row+8);y++){
								int color=image.getRGB(x,y);
								String hexString=Integer.toHexString(color);
								int index=GenesisColorUtil.findNearestColor(palette.colorsHex,hexString);
								//yes, these are getting transposed on purpose
								tile8x8.pixels[y-row][x-col]=index;
							}
						}
						int tileIndex=-1;
						boolean addTile=allowDuplicateTiles;
						if(!addTile){
							tileIndex=uniqueTiles.indexOf(tile8x8);
							addTile=tileIndex<0;
						}
						if(addTile){
							uniqueTiles.add(tile8x8);
							tileIndex=uniqueTiles.size()-1;
							String indexStr="\t; "+Integer.toHexString(tileIndex).toUpperCase();
							tileWriter.write(indexStr);
							tileWriter.write(newLine);
							tileWriter.write(tile8x8.toAsmLines());
							tileWriter.write(newLine);
						}
						if(createPattern){
							patternWriter.write("\tdc.w\t$"+Integer.toHexString(tileIndex).toUpperCase());
							patternWriter.write(newLine);
						}
						col+=8;
					}
					row+=8;
				}
				//update the include files
				String includePathRel=PathResolver.getRelativePath(tileIncludeFilePath,tileOutputPath);
				if(includePathRel.startsWith(PathResolver.PARENT_PATH)){
					includePathRel=includePathRel.substring(PathResolver.PARENT_PATH.length()+1);
				}
				StringBuffer includeString=new StringBuffer();
				includeString.append(entry.name);
				includeString.append("TilesStart:");
				includeString.append(newLine);
				includeString.append("\tinclude '");
				includeString.append(includePathRel);
				includeString.append("'");
				includeString.append(newLine);
				includeString.append(entry.name);
				includeString.append("TilesEnd:");
				includeString.append(newLine);
				includeString.append(newLine);
				tileIncludeWriter.write(includeString.toString());
				//close the tile writer
				tileWriter.flush();
				tileWriter.close();
				if(createPattern){
					includePathRel=PathResolver.getRelativePath(patternIncludeFilePath,patternOutputPath);
					if(includePathRel.startsWith("..")){
						includePathRel=includePathRel.substring(3);
					}
					includeString=new StringBuffer();
					includeString.append("\tinclude '");
					includeString.append(includePathRel);
					includeString.append("'");
					includeString.append(newLine);
					includeString.append(newLine);
					patternIncludeWriter.write(includeString.toString());
					//close the pattern writer
					patternWriter.flush();
					patternWriter.close();
				}
				//add the entry to the return map
				entry.tiles=uniqueTiles;
				returnMap.put(entry.name,entry);
			}
			return(returnMap);
		}catch(Exception x){
			if(currentEntry==null){
				System.err.println("Error in BuildTiles - currentEntry==null");
			}else{
				System.err.println("Error in BuildTiles - currentEntry.name="+currentEntry.name);
			}
			System.err.println("row="+row);
			System.err.println("col="+col);
			throw(x);
		}finally{
			try{if(tileIncludeWriter!=null){tileIncludeWriter.flush();tileIncludeWriter.close();}}catch(Exception x){ }
			try{if(patternIncludeWriter!=null){patternIncludeWriter.flush();patternIncludeWriter.close();}}catch(Exception x){ }
			try{if(tileWriter!=null){tileWriter.flush();tileWriter.close();}}catch(Exception x){ }
			try{if(patternWriter!=null){patternWriter.flush();patternWriter.close();}}catch(Exception x){ }
		}
	}
}
